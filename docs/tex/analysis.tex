\section{Аналитическая часть}

\subsection{Постановка задачи}

В соответствии с заданием на данную курсовую работу необходимо разработать загружаемый модуль ядра, предоставляющий статистику по количеству доступной и занятой оперативной памяти за выбранный промежуток времени, а также количеству системных вызовов.

Для выполнения поставленной задачи необходимо выполнить следующее:

\begin{itemize}
	\item проанализировать и сравнить существующие методы и способы решения задачи;
	\item описать алгоритм решения поставленной задачи и привести соответствующие схемы и IDEF0-диаграммы;
	\item разработать ПО в соответствии с заданием;
	\item проанализировать результаты работы разработанного ПО.
\end{itemize}

Требования к разрабатываемому ПО:
\begin{itemize}
	\item ПО должно выдавать:
	
	\begin{itemize}
		\item количество свободной, доступной и занятой оперативной памяти каждые 10 секунд;
		
		\item количество системных вызовов;
	\end{itemize}
	
	\item полученная информация должна записываться в виртуальную файловую систему /proc в файлы /proc/monitor/memory и /proc/monitor/syscalls.
\end{itemize}

Ограничения на разрабатываемое ПО:
\begin{itemize}
	\item ПО не предоставляет информацию о том, чем конкретно занята оперативная память;
	
	\item промежуток времени, через который фиксируется информация о памяти, задается в коде.
\end{itemize}

\subsection{Информация об оперативной памяти}

\subsubsection{Файл /proc/meminfo}

Одним из способов получения информации об использовании оперативной памяти является файл /proc/meminfo~\cite{meminfo}. Из /proc/meminfo можно получить информацию о свободной памяти, об используемой (и физической, и swap), а также о разделяемой (shared memory).

Основные показатели:

\begin{itemize}
	\item MemTotal -- общий объем оперативной памяти;
	
	\item LowFree -- объем свободной нижней области памяти;
	
	\item HighFree -- объем свободной верхней области памяти;
	
	\item MemFree -- сумма LowFree и HighFree;
	
	\item MemAvailable -- объем доступной оперативной памяти.
\end{itemize}

Помимо перечисленных в /proc/meminfo присутствует также множество других показателей, не существенных для данной работы.

Основной недостаток использования такого метода решения поставленной задачи заключается в необходимости постоянного обращения напрямую к указанному файлу и его анализа, что может привести к дополнительным временным затратам.

\subsubsection{Структура struct sysinfo}

Чтобы избежать чтения и анализа файла /proc/meminfo, можно использовать структуру struct sysinfo.

Структура struct sysinfo~\cite{sysinfo} хранит статистику о всей системе: информацию о времени, прошедшем с начала запуска системы, количество занятой памяти и так далее. В листинге~\ref{lst:sysinfo} приведено объявление рассматриваемой структуры.

\begin{lstlisting}[label={lst:sysinfo}, caption={структура struct sysinfo}]
	struct sysinfo {
		__kernel_long_t uptime;		/* Seconds since boot */
		__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
		__kernel_ulong_t totalram;	/* Total usable main memory size */
		__kernel_ulong_t freeram;	/* Free memory size */
		__kernel_ulong_t sharedram;	/* Amount of shared memory */
		__kernel_ulong_t bufferram;	/* Memory used by buffers */
		__kernel_ulong_t totalswap;	/* Total swap space size */
		__kernel_ulong_t freeswap;	/* swap space still available */
		__u16 procs;		   	/* Number of current processes */
		__u16 pad;		   	/* Explicit padding for m68k */
		__kernel_ulong_t totalhigh;	/* Total high memory size */
		__kernel_ulong_t freehigh;	/* Available high memory size */
		__u32 mem_unit;			/* Memory unit size in bytes */
		char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];	/* Padding: libc5 uses this.. */
	};
\end{lstlisting}

Наиболее важными полями для данной работы являются: totalram (общий объем используемой оперативной памяти) и freeram (объем свободной оперативной памяти).

Для инициализации этой структуры используется функция si\_meminfo(). Стоит отметить, что рассматриваемая структура не содержит информации о доступной памяти в системе. Для того чтобы получить эту информацию, необходимо воспользоваться функцией si\_mem\_available().

\subsubsection{Сравнительный анализ методов}

В таблице \ref{tab:compare} представлено сравнение рассмотренных методов решения поставленной задачи.

\begin{table}[!h]
	\captionsetup{justification=centering}
	\caption{\label{tab:compare} Сравнение методов}
	\begin{center}
		\begin{tabular}{|p{0.2\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.15\textwidth}|p{0.2\textwidth}|}
			\hline
			\textbf{Метод} & \textbf{Объем свободной памяти} & \textbf{Объем доступной памяти} & \textbf{Объем занятой памяти} & \textbf{Отсутствие необходимости работы с /proc}\\
			\hline
			/proc/meminfo & + & + & + & -- \\
			\hline
			struct sysinfo & + & -- & + & + \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\newpage

\subsection{Перехват функций}

\subsubsection{Модификация таблицы системных вызовов}

Все обработчики системных вызовов расположены в таблице sys\_call\_table. Подмена значений в этой таблице приведёт к смене поведения всей системы. Сохранив старое значение обработчика и подставив в таблицу собственный обработчик, можно перехватить любой системный вызов.

Особенности данного подхода:

\begin{itemize}
	\item минимальные временные расходы;
	\item не требуется специальная конфигурация ядра;
	\item техническая сложность реализации (поиск таблицы системных вызовов, обход защиты от модификации таблицы, атомарное и безопасное выполнение замены);
	\item из-за ряда оптимизаций, реализованных в ядре, некоторые обработчики невозможно перехватить~\cite{habr-profiling-linux};
	\item можно перехватывать только системные вызовы.
\end{itemize}

\subsubsection{kprobes}

kprobes~\cite{kprobes} -- интерфейс, предназначенный для отладки и трассировки ядра. Данный интерфейс позволяет устанавливать пред- и пост-обработчики для любой инструкции в ядре, а так же обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут изменять их значение. Таким образом, kprobes можно использовать как в целях мониторинга, так и для возможности повлиять на дальнейший ход работы ядра.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item перехват любой инструкции в ядре (реализуется с помощью точек останова, внедряемых в исполняемый код ядра);
	\item для расстановки и обработки точек останова необходимо большое количество процессорного времени~\cite{habr-profiling-linux};
	\item техническая сложность реализации (чтобы получить аргументы функции или значения её локальных переменных нужно знать, в каких регистрах, или в каком месте стека они находятся).
\end{itemize}

\subsubsection{Kernel tracepoints}

Kernel tracepoints~\cite{kernel-tracepoints} -- это фреймворк для трассировки ядра, реализованный через статическое инструментирование кода (т.~е. выполняемое однократно перед запуском программы).

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item минимальные накладные расходы -- необходимо только вызвать функцию трассировки в соответствующем месте;
	\item не все функции ядра статически инструментированы; 
	\item не работает, если ядро не сконфигурировано должным образом~\cite{habr-profiling-linux}.
\end{itemize}

\subsubsection{ftrace}

ftrace~\cite{ftrace} -- это фреймворк для трассировки ядра на уровне функций, реализованный на основе ключей компилятора -pg и -mfentry, которые вставляют в начало каждой функции вызов специальной трассировочной функции mcount() или \_\_fentry\_\_().

Для большинства современных архитектур процессора доступна оптимизация: динамический ftrace~\cite{ftrace-habr}. Ядро знает расположение всех вызовов функций mcount() или \_\_fentry()\_\_ и на ранних этапах загрузки ядра подменяет их машинный код на инструкцию NOP. При включении трассировки вызовы ftrace добавляются обратно в соответствующие функции.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item имеется возможность перехватить любую функцию;
	\item перехват совместим с трассировкой;
	\item фреймворк зависит от конфигурации ядра, но в популярных конфигурациях установлены все необходимые флаги для работы; 
\end{itemize}

\subsubsection{Сравнительный анализ методов}

В таблице \ref{tab:analyze} приведено сравнение рассмотренных методов.

\begin{table}[h]
	\centering
	\captionsetup{justification=centering}
	\caption{\label{tab:analyze} Методы перехвата системных вызовов}
	\begin{tabular}{ | p{4cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | }
		\hline
		Название & Дин. загрузка & Перехват любых функций & Любая конфигурация ядра & Простота реализации \\
		\hline
		Модификация таблицы системных вызовов & + & -- & + & -- \\
		\hline
		kprobes & + & + & + & -- \\
		\hline
		kernel tracepoints & + & + & -- & + \\
		\hline
		ftrace & + & + & -- & + \\
		\hline
	\end{tabular}
\end{table}

\subsection*{Выводы}

В этом разделе была проанализирована поставленная задача и методы ее решения. В ходе анализа для получения информации о памяти была выбрана структура struct sysinfo, т.~к. такой подход позволяет не работать напрямую с файлом /proc/meminfo. При этом для получения информации о доступной памяти будет использоваться функция si\_mem\_available().

Для перехвата функций был выбран фреймворк ftrace, так как он позволяет перехватить любую функцию, зная лишь её имя, может быть загружен в ядро динамически и не требует специальной сборки ядра.


