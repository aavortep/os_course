\section{Аналитическая часть}

\subsection{Постановка задачи}

В соответствии с заданием необходимо разработать загружаемый модуль ядра, предоставляющий статистику по количеству доступной и занятой оперативной памяти за выбранный промежуток времени.

Требования к разрабатываемому ПО:
\begin{itemize}
	\item ПО должно выдавать количество свободной, доступной и занятой оперативной памяти каждые 10 секунд;
	
	\item полученная информация должна записываться в виртуальную файловую систему /proc в файл /proc/monitor/memory.
\end{itemize}

Ограничения на разрабатываемое ПО:
\begin{itemize}
	\item ПО не предоставляет информацию о том, чем конкретно занята оперативная память;
	
	\item промежуток времени задается внутри программы и может быть изменен только в коде.
\end{itemize}

\subsection{Основные понятия}

\textbf{Свободная память} -- память, которая в настоящее время ни для чего не используется~\cite{freemem}.

\textbf{Доступная память} -- память, которая используется, но может быть предоставлена для новых или существующих процессов.

\textbf{Занятая память} -- память, которая на данный момент уже используется процессами.

\textbf{Нижняя область памяти} -- область, к которой ядро может обращаться напрямую. Все структуры данных ядра находятся в этой области.

\textbf{Верхняя область памяти} -- область, доступ к которой осуществляется через косвенные механизмы. Здесь находится кэш данных.

\subsection{Анализ методов решения}

\subsubsection{Файл /proc/meminfo}

Одним из способов получения информации об использовании памяти является файл /proc/meminfo~\cite{meminfo}. Из /proc/meminfo можно получить информацию о свободной памяти, об используемой (и физической, и swap), а также о разделяемой (shared memory) и буферах.

Основные показатели:

\begin{itemize}
	\item MemTotal -- общий объем оперативной памяти;
	
	\item LowFree -- объем свободной нижней области памяти;
	
	\item HighFree -- объем свободной верхней области памяти;
	
	\item MemFree -- сумма LowFree и HighFree;
	
	\item MemAvailable -- объем доступной оперативной памяти.
\end{itemize}

Помимо перечисленных в /proc/meminfo присутствует также множество других показателей, не существенных для данной работы.

Основной недостаток использования такого метода решения поставленной задачи заключается в необходимости постоянного обращения напрямую к указанному файлу и его анализа, что может привести к дополнительным временным затратам.

\subsubsection{Структура struct sysinfo}

Чтобы избежать чтения и анализа упомянутого выше файла, можно использовать структуру struct sysinfo.

Структура struct sysinfo~\cite{sysinfo} хранит статистику о всей системе: информацию о времени, прошедшем с начала запуска системы, количество занятой памяти и так далее. В листинге~\ref{lst:sysinfo} приведено объявление рассматриваемой структуры.

\begin{lstlisting}[label={lst:sysinfo}, caption={структура struct sysinfo}]
	struct sysinfo {
		__kernel_long_t uptime;		/* Seconds since boot */
		__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
		__kernel_ulong_t totalram;	/* Total usable main memory size */
		__kernel_ulong_t freeram;	/* Free memory size */
		__kernel_ulong_t sharedram;	/* Amount of shared memory */
		__kernel_ulong_t bufferram;	/* Memory used by buffers */
		__kernel_ulong_t totalswap;	/* Total swap space size */
		__kernel_ulong_t freeswap;	/* swap space still available */
		__u16 procs;		   	/* Number of current processes */
		__u16 pad;		   	/* Explicit padding for m68k */
		__kernel_ulong_t totalhigh;	/* Total high memory size */
		__kernel_ulong_t freehigh;	/* Available high memory size */
		__u32 mem_unit;			/* Memory unit size in bytes */
		char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(__u32)];	/* Padding: libc5 uses this.. */
	};
\end{lstlisting}

Для инициализации этой структуры используется функция si\_meminfo(). Стоит отметить, что рассматриваемая структура не содержит информации о доступной памяти в системе. Для того чтобы получить эту информацию, необходимо воспользоваться функцией si\_mem\_available().

\subsection{Загружаемые модули ядра}

Одной из особенностей ядра Linux является способность расширения функциональности во время работы, без необходимости компиляции ядра заново. Часть кода, которая может быть добавлена в ядро во время работы, называется \textbf{модулем ядра}. Ядро Linux предлагает поддержку большого числа классов модулей. Каждый модуль -- это подготовленный объектный код, который может быть загружен в работающее ядро, а позднее может быть выгружен из ядра. Чтобы загрузить модуль в ядро, необходимо воспользоваться командой <<insmod name.ko>>. А для выгрузки модуля -- командой <<rmmod name.ko>>.

Каждый модуль ядра сам регистрирует себя для того, чтобы обслуживать в будущем запросы, и его функция инициализации немедленно прекращается. Задача инициализации модуля заключается в подготовке функций модуля для последующего вызова. Функция выхода из модуля вызывается перед выгрузкой модуля из ядра. Функция выхода должна отменить все изменения, сделанные функцией инициализации, освободить захваченные в процессе работы модуля ресурсы. Для регистрации функций инициализации и выхода используются функции <<module\_init(func\_name)>> и <<module\_exit(func\_name)>> соответственно.

Модуль связан только с ядром и может вызывать только те функции, которые экспортированы ядром. Для экспорта функций в модуле необходимо использовать <<EXPORT\_SYMBOL(func\_name)>>.

\subsection{Пространство ядра и пространство пользователя}

Приложения работают в пользовательском пространстве, а ядро и его модули -- в пространстве ядра. Такое разделение пространств -- базовая концепция теории операционных систем.

Ролью операционной системы является обеспечение программ надёжным доступом к аппаратной части компьютера. Операционная система должна обеспечивать независимую работу программ и защиту от несанкционированного доступа к ресурсам. Решение этих задач становится возможным только в том случае, если процессор обеспечивает защиту системного программного обеспечения от прикладных программ.

Выбранный подход заключается в обеспечении разных режимов работы (или уровней) в самом центральном процессоре. Уровни играют разные роли и некоторые операции на более низких уровнях не допускаются. Программный код может переключить один уровень на другой только ограниченным числом способов. Все современные процессоры имеют не менее двух уровней защиты.

Ядро Linux выполняется на самом высоком уровне, где разрешено выполнение любых инструкций и доступ к произвольным участкам памяти. А приложения выполняются на самом низком уровне, в котором процессор регулирует прямой доступ к оборудованию и несанкционированный доступ к памяти. Ядро выполняет переход из пользовательского пространства в пространство ядра, когда приложение делает системный вызов или приостанавливается аппаратным прерыванием.

\subsection{Виртуальная файловая система /proc}

Для организации доступа к разнообразным файловым системам в Unix используется промежуточный слой абстракции -- \textbf{виртуальная файловая система}. С точки зрения программиста, виртуальная файловая система организована как специальный интерфейс. Виртуальная файловая система объявляет API доступа к ней, а реализацию этого API отдает драйверам конкретных файловых систем.

Виртуальная файловая система /proc -- специальный интерфейс, с помощью которого можно получить некоторую информацию о ядре в пространство пользователя. /proc отображает в виде дерева каталогов внутренние структуры ядра.

В каталоге /proc в Linux присутствуют несколько деревьев файловой системы. В основном дереве каждый каталог имеет числовое имя, которое соответствует PID процесса. Файлы в этих каталогах соответствуют структуре task\_struct, которая имеет вид~\cite{task_struct}:

\begin{lstlisting}[caption={структура task\_struct с наиболее важными полями}]
	struct task_struct {
	#ifdef CONFIG_THREAD_INFO_IN_TASK
		struct thread_info		thread_info;
	#endif
		
		unsigned int			__state;
	...
		unsigned int			flags;
	...
	#ifdef CONFIG_SMP
		int						on_cpu;
	...
		int						recent_used_cpu;
		int						wake_cpu;
	#endif
	...
	#ifdef CONFIG_CGROUP_SCHED
		struct task_group		*sched_task_group;
	#endif
	...
		struct sched_info		sched_info;
		struct list_head		tasks;
	...
	};
\end{lstlisting}

Так, например, с помощью команды <<cat /proc/1/cmdline>>, можно узнать аргументы запуска процесса с идентификатором, равным единице.

Ядро предоставляет возможность добавить своё дерево в каталог /proc. Внутри ядра объявлена специальная структура struct proc\_ops~\cite{proc_ops}. Эта структура содержит внутри себя указатели на функции чтения файла, записи в файл и прочие, определенные пользователем. В листинге~\ref{lst:procops} представлено объявление данной структуры в ядре.

\begin{lstlisting}[label={lst:procops}, caption={структура struct proc\_ops}]
	struct proc_ops {
		unsigned int proc_flags;
		int	(*proc_open)(struct inode *, struct file *);
		ssize_t	(*proc_read)(struct file *, char __user *, size_t, loff_t *);
		ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
		ssize_t	(*proc_write)(struct file *, const char __user *, size_t, loff_t *);
		/* mandatory unless nonseekable_open() or equivalent is used */
		loff_t	(*proc_lseek)(struct file *, loff_t, int);
		int	(*proc_release)(struct inode *, struct file *);
		__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
		long	(*proc_ioctl)(struct file *, unsigned int, unsigned long);
		#ifdef CONFIG_COMPAT
		long	(*proc_compat_ioctl)(struct file *, unsigned int, unsigned long);
		#endif
		int	(*proc_mmap)(struct file *, struct vm_area_struct *);
		unsigned long (*proc_get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
	} __randomize_layout;
\end{lstlisting}

С помощью вызова функций proc\_mkdir() и proc\_create() в модуле ядра можно зарегистрировать свои каталоги и файлы в /proc соответственно. Функции copy\_to\_user() и copy\_from\_user() реализуют передачу данных из пространства ядра в пространство пользователя и наооборот.

Таким образом, с помощью виртуальной файловой системы /proc можно получать (или передавать) какую-либо информацию из пространства ядра в пространство пользователя (из пространства пользователя в пространство ядра).

\subsection*{Выводы}

В этом разделе была проанализирована поставленная задача и методы ее решения. В ходе анализа для получения информации о памяти была выбрана структура struct sysinfo, т.~к. такой подход позволяет не работать напрямую с файлом /proc/meminfo. Помимо этого были рассмотрены особенности загружаемых модулей ядра и понятия пространства ядра и пространства пользователя, а также рассмотрен способ взаимодействия этих двух пространств с целью передачи данных из одного в другое.


