\section{Аналитический раздел}

\subsection{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать загружаемый модуль ядра, предоставляющий статистику по количеству доступной и занятой оперативной памяти за выбранный промежуток времени, а также количеству системных вызовов.

Для выполнения поставленной задачи необходимо выполнить следующее:

\begin{itemize}
	\item выбрать способ, наиболее отвечающий поставленному заданию;
	\item разработать алгоритмы и структуру ПО;
	\item разработать ПО;
	\item проанализировать результаты работы разработанного ПО.
\end{itemize}

Требования к разрабатываемому ПО:
\begin{itemize}
	\item ПО должно выводить на экран терминала:
	
	\begin{itemize}
		\item информацию об оперативной памяти за определенный промежуток времени;
		
		\item количество системных вызовов;
	\end{itemize}
	
	\item полученная информация должна записываться в виртуальную файловую систему /proc в файлы /proc/monitor/memory и /proc/monitor/syscalls.
\end{itemize}

\subsection{Информация об оперативной памяти}

\subsubsection{Структура struct sysinfo}

Структура struct sysinfo~\cite{sysinfo} хранит статистику о всей системе: информацию о времени, прошедшем с начала запуска системы, количество занятой памяти и так далее. В листинге~\ref{lst:sysinfo} приведено объявление рассматриваемой структуры.

\begin{lstlisting}[label={lst:sysinfo}, caption={структура struct sysinfo}]
	struct sysinfo {
		__kernel_long_t uptime;		/* Seconds since boot */
		__kernel_ulong_t loads[3];	/* 1, 5, and 15 minute load averages */
		__kernel_ulong_t totalram;	/* Total usable main memory size */
		__kernel_ulong_t freeram;	/* Free memory size */
		__kernel_ulong_t sharedram;	/* Amount of shared memory */
		__kernel_ulong_t bufferram;	/* Memory used by buffers */
		__kernel_ulong_t totalswap;	/* Total swap space size */
		__kernel_ulong_t freeswap;	/* swap space still available */
		__u16 procs;		   	/* Number of current processes */
		__kernel_ulong_t totalhigh;	/* Total high memory size */
		__kernel_ulong_t freehigh;	/* Available high memory size */
		__u32 mem_unit;			/* Memory unit size in bytes */
		char _f[20-2*sizeof(__kernel_ulong_t)-sizeof(int)];	/* Padding to 64 bytes */
	};
\end{lstlisting}

Наиболее важными полями для данной работы являются: totalram (общий объем используемой оперативной памяти), freeram (объем свободной оперативной памяти), sharedram (объем разделяемой памяти), bufferram (память, используемая буферами), totalswap (общий размер swap пространства), totalhigh (общий объем верхней области памяти (HMA, память, зарезервированная для системного аппаратного обеспечения)), freehigh (объем свободной HMA).

Для инициализации этой структуры используется функция si\_meminfo(). Стоит отметить, что рассматриваемая структура не содержит информации о доступной памяти в системе. Для того чтобы получить эту информацию, необходимо воспользоваться функцией si\_mem\_available().

При этом в качестве промежутка времени, через который фиксируется состояние оперативной памяти, выбрана 1 секунда. Данный выбор обусловлен тем, что интервал больше одной секунды является слишком широким для сбора такой статистики, в то время как информация, приходящая чаще, чем через секунду, будет сложна для анализа из-за ее объема.

\newpage

\subsection{Количество системных вызовов}

Для подсчета количества системных вызовов необходимо перехватывать эти системные вызовы.

Перехват функции заключается в изменении некоторого адреса в памяти процесса или кода в теле функции таким образом, чтобы при вызове этой функции управление передавалось не ей, а функции, которая будет её подменять. Эта функция, работая вместо системной, выполняет какие-то запланированные действия (в данном случае увеличивает счетчик количества вызовов перехваченной функции), и затем, либо вызывает оригинальный обработчик системного вызова, либо не вызывает его вообще.

Далее будут рассмотрены различные существующие подходы к перехвату вызываемых функций и выбран наиболее подходящий для реализации в данной работе.

\subsubsection{Модификация таблицы системных вызовов}

Все обработчики системных вызовов расположены в таблице sys\_call\_table. Подмена значений в этой таблице приведёт к смене поведения всей системы. Сохранив старое значение обработчика и подставив в таблицу собственный обработчик, можно перехватить любой системный вызов.

Особенности данного подхода:

\begin{itemize}
	\item минимальные временные расходы;
	\item не требуется специальная конфигурация ядра;
	\item техническая сложность реализации (поиск таблицы системных вызовов, обход защиты от модификации таблицы, атомарное и безопасное выполнение замены);
	\item из-за ряда оптимизаций, реализованных в ядре, некоторые обработчики невозможно перехватить~\cite{habr-profiling-linux};
	\item можно перехватывать только системные вызовы.
\end{itemize}

\subsubsection{Linux Security Modules}

Linux Security Modules (LSM)~\cite{linux-security-api} -- это специальный интерфейс, созданный для перехвата функций. В критических местах кода ядра расположены вызовы security-функций, которые вызывают коллбеки (англ. callback), установленные security-модулем. Данный модуль может изучать контекст операции и принимать решение о её разрешении или запрете.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item security-модули являются частью ядра и не могут быть загружены динамически;
	\item в стандартной конфигурации сборки ядра флаг наличия LSM неактивен -- большинство уже готовых сборок ядра не содержат внутри себя интерфейс LSM;
	\item в системе может быть только один security-модуль.
\end{itemize}

Таким образом, для использования Linux Security Modules необходимо поставлять собственную сборку ядра Linux, что является трудоёмким вариантом -- как минимум, придётся тратить время на сборку ядра. Кроме того, данный интерфейс обладает излишним функционалом (например решение о блокировке какой-либо операции), который не потребуется в написании разрабатываемого модуля ядра.

\subsubsection{kprobes}

kprobes~\cite{kprobes} -- интерфейс, предназначенный для отладки и трассировки ядра. Данный интерфейс позволяет устанавливать пред- и пост-обработчики для любой инструкции в ядре, а так же обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут изменять их значение. Таким образом, kprobes можно использовать как в целях мониторинга, так и для возможности повлиять на дальнейший ход работы ядра.

Особенности рассматриваемого интерфейса:

\begin{itemize}
	\item перехват любой инструкции в ядре (реализуется с помощью точек останова, внедряемых в исполняемый код ядра);
	\item для расстановки и обработки точек останова необходимо большое количество процессорного времени~\cite{habr-profiling-linux};
	\item техническая сложность реализации (чтобы получить аргументы функции или значения её локальных переменных нужно знать, в каких регистрах, или в каком месте стека они находятся).
\end{itemize}

\subsubsection{Kernel tracepoints}

Kernel tracepoints~\cite{kernel-tracepoints} -- это фреймворк для трассировки ядра, реализованный через статическое инструментирование кода (т.~е. выполняемое однократно перед запуском программы).

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item минимальные накладные расходы -- необходимо только вызвать функцию трассировки в соответствующем месте;
	\item не все функции ядра статически инструментированы; 
	\item не работает, если ядро не сконфигурировано должным образом~\cite{habr-profiling-linux}.
\end{itemize}

\subsubsection{ftrace}

ftrace~\cite{ftrace} -- это фреймворк для трассировки ядра на уровне функций, реализованный на основе ключей компилятора -pg и -mfentry, которые вставляют в начало каждой функции вызов специальной трассировочной функции mcount() или \_\_fentry\_\_().

Для большинства современных архитектур процессора доступна оптимизация: динамический ftrace~\cite{ftrace-habr}. Ядро знает расположение всех вызовов функций mcount() или \_\_fentry()\_\_ и на ранних этапах загрузки ядра подменяет их машинный код на инструкцию NOP. При включении трассировки вызовы ftrace добавляются обратно в соответствующие функции.

Особенности рассматриваемого фреймворка:

\begin{itemize}
	\item имеется возможность перехватить любую функцию;
	\item перехват совместим с трассировкой;
	\item фреймворк зависит от конфигурации ядра, но в популярных конфигурациях установлены все необходимые флаги для работы; 
\end{itemize}

\subsubsection{Сравнительный анализ методов}

В таблице \ref{tab:analyze} приведено сравнение рассмотренных методов.

\begin{table}[h]
	\centering
	\captionsetup{justification=centering}
	\caption{\label{tab:analyze} Методы перехвата системных вызовов}
	\begin{tabular}{ | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | p{2cm} | }
		\hline
		Название & Дин. загрузка & Перехват любых функций & Любая конфигурация ядра & Простота реализации & Информация об адресе перехватываемой функции & Наличие документации \\
		\hline
		Модификация таблицы системных вызовов & + & -- & + & -- & + & -- \\
		\hline
		Linux Security Module & -- & + & -- & -- & -- & -- \\
		\hline
		kprobes & + & + & + & -- & + & + \\
		\hline
		kernel tracepoints & + & + & -- & + & -- & -- \\
		\hline
		ftrace & + & + & -- & + & -- & + \\
		\hline
	\end{tabular}
\end{table}

По результатам сравнения для перехвата системных вызовов был выбран ftrace, так как он удовлетворяет большинству важных требований (возможность динамической загрузки, перехвата системных вызовов, простота реализации и наличие документации). При этом для получения информации об адресе перехватываемой функции можно использовать kprobes.

\subsection*{Выводы}

В результате проведенного анализа для реализации перехвата системных вызовов был выбран фреймворк ftrace, так как он не требует специальной сборки ядра и предоставляет возможность динамической загрузки в ядро. При этом для поиска адреса перехватываемой функции был выбран интерфейс kprobes, так как ftrace не предоставляет такой возможности.

Помимо этого были рассмотрены структура struct sysinfo и функция\\ si\_mem\_available, предоставляющие информацию об объеме доступной и занятой оперативной памяти, объеме разделяемой памяти, размере swap пространства и т.~д. При этом в качестве промежутка времени, через который фиксируется информация об оперативной памяти, была выбрана 1 секунда.


